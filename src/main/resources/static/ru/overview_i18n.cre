= Интернационализация приложений (пакет purelib.i18n)

Интернационализация (другой вариант - локализация) приложений необходима в том случае, если разработчики намерены создавать мультиязыковое приложение. Вся библиотека PL разрабатывалась из предположения, что такое намерение у разработчика //непременно есть//. Основу локализации в PL образует интерфейс [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/Localizer.html|Localizer]] из пакета [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/package-summary.html|purelib.i18n.interfaces]]. Он поддерживает следующие типы операций:

* получить локализованную строку-значение, соответствующее заданному ключу (метод **getValue(...)**)
* получить файл "помощи", соответствующий заданному ключу (метод **getContent(...)**)

В приложении может существовать более чем один локализатор (например, собственный локализатор может находиться в подключаемом модуле). В связи с этим в интерфейсе локализатора присутствует ряд операций, позволяющих вести в программе //дерево// локализаторов:

* подключение локализатора к существующему дереву локализаторов в виде "дочки" (методы **push(...)** и **pop(...)**)
* "расширение" существующего локализатора дополнительным локализатором (методы **add(...)** и **remove(...)**)
* обход дерева локализаторов (методы **walkDown(...)** и **walkUp(...)**) а также исследование отдельных узлов дерева локализаторов (списки ключей, наличие ключа, поддерживаемые языки)

Локализатор имеет также механизм подписки на событие "изменение локали" (методы **addLocaleChangeListener(...)** и **removeLocaleChangeListener(...)**). При изменении текущей локали локализатора (**не** приложения!) все подписанные слушатели получат об этом соответствующее уведомление.

Помимо указанных возможностей, локализатор поддерживает также механизм **автоподстановки** значений (метод **associateValue(...)**). Механизм автоподстаноски позволяет употреблять в локализованных строках конструкцию вида **${<имя_переменной>}**, которая при выборке локализованной строки будет автоматически заменена на текущее значение подстановочной переменной. Данный механизм в точности соответствует работе метода **substitute(...)** класса [[/doc/chav1961.purelib/chav1961/purelib/basic/CharUtils.html|CharUtils]].

В пакете [[/doc/chav1961.purelib/chav1961/purelib/i18n/package-summary.html|purelib.i18n]] имеется класс [[/doc/chav1961.purelib/chav1961/purelib/i18n/AbstractLocalizer.html|AbstractLocalizer]], в котором реализована основная функциональность интерфейса [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/Localizer.html|Localizer]]. Наcтоятельно рекомендую пользоваться им при написании реализации своих собственных локализаторов. Интерфейс [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/Localizer.html|Localizer]] наследуется от интерфейса [[https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html|AutoCloseable]], поэтому может употребляться в конструкции **try-with-resource**.

Большинство методов интерфейса [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/Localizer.html|Localizer]] могут выбрасывать при работе исключение [[/doc/chav1961.purelib/chav1961/purelib/basic/exceptions/LocalizationException.html|LocalizationException]]. Данное исключение является обязательным для обработки, поэтому при работе с локализаторами необходимо использовать либо **try-блоки**, либо опцию **throws**.

Рассмотрим более подробно ряд вопросов по  работе с локализаторами:

* [[#Создание локализаторов|создание]] локализаторов
* алгоритм [[#Обработка ключей|обработки ключей]] при поиске
* алгоритм [[#Выборка файла помощи|выборки файла помощи]] при поиске
* алгоритм [[#Извещение об изменении локали|извещения]] об изменении локали

==Создание локализаторов

Локализаторы, как и файловые системы, в библиотеке PL подключаются через механизм [[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html|SPI]]. В пакете [[/doc/chav1961.purelib/chav1961/purelib/i18n/package-summary.html|purelib.i18n]] имеется класс [[/doc/chav1961.purelib/chav1961/purelib/i18n/LocalizerFactory.html|LocalizerFactory]], с помощью которого можно получить экземпляр локализатора по его [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]]. Схема всех URI для локализаторов называется **i18n**, специфичный для данной схемы контент, в свою очередь, также содержат соответствующую тому или иному типу локализатора схему, и дополнительный идентификатор ресурса, описывающий расположение ресурса локализатора. В библиотеке PL имеются классы, реализующие следующие типы локализаторов:
|= тип локализатора |= форма записи URI |= комментарий |
|Локализатор на базе файлов [[https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html|Properties]] | i18n:prop:<URI_файла> | Переходник к стандартному локализатору JRE [[https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html|ResourceBundle]]|
|Локализатор на базе файлов XML | i18n:xml:<URI_файла> | Локализатор на базе файла XML (см класс [[/doc/chav1961.purelib/chav1961/purelib/i18n/XMLLocalizer.html|XMLLocalizer]])|
Пример получения локализатора:
{{{try(Localizer	l = LocalizerFactory.getLocalizer(URI.create("i18n:xml:file:./content.xml"))) {
	/* TODO:...*/
} }}}

Библиотека PL поддерживает в классе [[/doc/chav1961.purelib/chav1961/purelib/i18n/LocalizerFactory.html|LocalizerFactory]] //кеш// локализаторов, поэтому повторный запрос локализатора с там же URL не приводит к созданию новой инстанции локализатора. Это следует иметь в виду при подключении локализатора в дерево локализаторов. 

Если в отдельных частях вашего приложения (например, в подключаемых модулях) имеется свой собственный локализатор, в начале работы рекомендую подсоединить его в общему дереву локализаторов в качестве "дочки", а после окончания работы - отсоединить его:

{{{try(Localizer	local = LocalizerFactory.getLocalizer(URI.create("i18n:<собственный_локализатор>"))) {
	applicationLocalizer.push(local);
	/* TODO:...*/
	applicationLocalizer.pop(local);
} }}}

В этом случае вы сможете через переменную **local** получить доступ не только к своим собственным локализованным строкам, но и ко всем локализованным строкам приложения в целом (см ниже).

При запросе локализатора следует иметь в виду, что функциональность стандартного локализатора JRE [[https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html|ResourceBundle]], начиная с Java 1.9, не работает в именованных модулях. По этой причине не рекомендую в дальнейшем применять этот тип локализатора в своих приложениях.

==Обработка ключей

При вызове методов **getValue(...)** и **getContent(...)** алгоритм поиска ключа в точности соответствует алгоритму работы метода **walkUp(...)**. Этот алгоритм является унифицированным и повсеместно используется внутри библиотеки PL. Детальное его описание см [[./overview_enumerations.cre#Нумерация NodeEnterMode и ContinueMode|здесь]]. Из него, в частности, вытекают некоторые следствия:
* при подсоединении локализатора в дерево локализаторов в качестве "дочки" этот локализатор //может// содержать ключи, совпадающие с ключами вышележащих локализаторов. В этом случае ключ локализатора-"дочки" имеет приоритет перед ключем вышележащего локализатора
* при подсоединении локализатора в дерево локализаторов в качестве "соседа" этот локализатор //не должен// содержать ключи, совпадающие с ключами локализаторов-"соседей" (в противном случае при выполнении операции подсоединения будет выброшего исключение [[/doc/chav1961.purelib/chav1961/purelib/basic/exceptions/LocalizationException.html|LocalizationException]])

Библиотека PL имеет свой внутренний локализатор, который используется для локализации всех компонент самой библиотеки. Доступ к нему можно получить через класс [[/doc/chav1961.purelib/chav1961/purelib/basic/PureLibSettings.html|PureLibSettings]] (статическое поле **PURELIB_LOCALIZER**). Настоятельно рекомендуем использовать этот локализатор в качестве //корня// дерева локализаторов вашего приложения.

==Выборка файла помощи

Выборка файла помощи, вообще говоря, зависит от конкретной реализации интерфейса [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/Localizer.html|Localizer]]. В случае, если для реализации в качестве базового класса был использован класс [[/doc/chav1961.purelib/chav1961/purelib/i18n/AbstractLocalizer.html|AbstractLocalizer]], в поле значения локализованной строки для данного ключа может быть употреблена конструкция вида:

Key = **uri(**<uri_файла_помощи>[?[**encoding= **<кодировка>][&{**mime= **<тип_содержимого_файла>~|**sourceMime= **<тип_содержимого_файла>&**targetMime= **<тип_содержимого_файла>}]]>**)**

Она перенаправляет запрос на выборку на указанный URI (природа его может быть любая), а также указывает, в каком формате представлены данные (параметр строки запроса **mime**). В случае, если при выборке требуется преобразование формата данных из одного вида в другой, используются параметры строки запроса **sourceMime** и **targetMime**. Текущая реализация поддерживает следующие варианты преобразования форматов:

|= sourceMime |= targetMime=text/plain |= targetMime=text/html |
|text/plain| * | - |
|text/html| * | * |
|text/x-wiki.creole| * | * |
Кодировкой исходных данных по умолчанию считается **UTF-8**.

==Извещение об изменении локали

При вызове метода **setCurrentLocale(...)** интерфейс [[/doc/chav1961.purelib/chav1961/purelib/i18n/interfaces/Localizer.html|Localizer]] инциирует процесс извещения всех заинтересованных лиц об изменении локали. Алгоритм извещения в точности соответствует алгоритму работы метода **walkDown(...)**. Этот алгоритм является унифицированным и повсеместно используется внутри библиотеки PL. Детальное его описание см [[./overview_enumerations.cre#Нумерация NodeEnterMode и ContinueMode|здесь]]. Из него, в частности, вытекают некоторые следствия:
* изменение локали не распространяется на все дерево локализаторов, а только на тот локализатор, на инстанции которого был вызван метод **setCurrentLocale(...)**, и на все его "дочки". Для того, чтобы известить //всех// подписчиков данного события, необходимо вызывать данный метод на //корне// дерева локализаторов (в качестве которого я уже советовал использовать локализатор самой библиотеки PL).
* изменение локали не распространяется на "соседей" локализатора, на котором был вызван метод **setCurrentLocale(...)**

Библиотека PL не содержит никаких встроенных средств контроля за изменением локали со стороны ОС, более того - текущая локаль в локализаторах может отличаться от таковой в самом приложении. Если возможность отследить изменение локал 	и со стороны ОС необходима, следует реализовать ее самостоятельно.

