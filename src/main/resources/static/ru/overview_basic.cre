= Пакет purelib.basic и его подпакеты. Общий обзор

Классы пакета **purelib.basic** и его подпакетов можно разделить на несколько групп:

* классы, предназначенные для поддержки консольных приложений
* классы, поддерживающие средства конфигурирования приложений
* классы, предназначенные для логирования работы приложений
* классы, поддерживающие механизм Java Scripting
* динамические массивы примитивных типов
* динамические построители кода
* утилитные классы

Рассмотрим подробнее каждую из упомянутых групп. 

== Поддержка консольных приложений

Для поддержки консольных приложений в библиотеке PL имеются два класса:

* класс [[|ArgParser]], предназначенный для разбора аргументов командной строки
* класс [[|ConsoleCommandManager]], преднаначенный для обработки и выполнения команд, вводимых с консоли

Класс ArgParser автоматизирует процессы разбора аргументов командной строки приложения. Он поддерживает обработку позиционных и ключевых парамеров, различные типы аргументов (булевы, целочисленные, вещественные, строковые аргументы, различные виды URI, а также нумерации), опциональные и обязательные параметры. Для целочисленных параметров дополнительно можно указывать допустимый диапазон и/или список значений (например, для номера порта). С его помощью можно также выдать на консоль справку по использованию параметров запуска.

Класс ConsoleCommandManager принимает на вход строку, вводимую с консоли (поток System.in), выполняет ее синтаксический разбор и вызов на выполнение соответствующего обработчика команд. Обработчики команд - подключаемые. Задачи такого плана в практике программирования возникают нечасто, тем не менее сталкиваться с ними мне приходилось.

== Средства конфигурации приложений

Главный класс, активно используемый самой библиотекой PL для собственной конфигурации, называется [[|PureLibSettings]]. Через него в системе доступны локализатор [[|PureLibLocalizer]], таймер для выполнения периодического обслуживания бибилотеки PL, а также набор системных свойств приложения (переменные -D). В этих же свойствах можно задать (при запуске приложения) URI источника данных конфигурации (параметр -Dpurelib.settings.source), из которого система загрузит параметры конфигурации вашего приложения. В качестве URI допустимо использовать любой правильный URI, поддерживаемый приложеним, в тоом числе и ссылки на компоненты файловых систем. Доступ к парамтерам конфигурации можно получить через метод [[|PureLibSettings.instance()]]. Тип возвращаемого этим методом результата - [[|SubstitutableProperties]]. Класс этот - "дочка" класса Properties, обеспечивающий две дополнительные возможности:

* механизм автоподстановки в параметрах источника данных конфигурации (например key1 = before ${key2} after)
* механизм преобразования значений параметров в заданный тип (булево, целочисленное, вещественное, нумерация, URI, File, InputStream и ряд других)

== Средства логирования работы приложений

Логгеры нынче не пишет только ленивый. Однако, несмотря на, я бы сказал, //чрезмерное//, богатство выбора, все эти логгеры страдают двумя недостатками:

* логов, выдаваемых ими, бывает слишком мало, и по ним ничего нельзя понять
* логов, выдаваемых ими, бывает слишком много, и по ним тоже ничего нельзя понять

Одна из причин такого положения заключается в том, что заранее никогда не известно, когда и какая информация из логов может потребоваться для анализа ситуации. Типичный сценарий работы с логами имеет вид:

* получили неожиданное сообщение об ошибке, из которого ничего нельзя понять
* включили всю мыслимую трассу
* запустили приложение или задачу второй раз
* получили километры отладочной информации
* сели чесать репу

Т.е. чаще всего логи системы используются разработчиками как //еще одно// средство отладки приложений. Такой взгляд, вообще говоря, совершенно неверен. Достаточно сказать, что для многих клиентов эти логи представляют собой, по сути дела, протокол работы системы, и по этой причине подлежат //обязательному// хранению весьма длительное время. Визгу по поводу помойки, в которую обычно превращается такой лог, бывает предостаточно. В логгерах, безусловно, есть средства конфигурирования (в том числе и на лету), но их наличие, создавая иллюзию "все под контролем", никоим образом не избавляет от только что озвученного сценария. Вдоволь нахлебавшить этими изделиями на ряде проектов, я, в конце концов, разработал собственный вариант реализации логгеров. Упор в них сделан не на возможности конфигурирования, а совсем на другое. 

Основой всех логгеров в системе является интерфейс [[|LoggerFacade]]. Отличительные его особенности следующие:

* режим редукции сообщений
* транзакционный режим логирования

Режим редукции сообщений позволяет автоматически выбрасывать из логов части трассы стеков, если в лог записывается сообщение об ошибке. Существуют несколько вариантов такого "выброса" в произвольных комбинациях:

* исключать из стеков все участки кода стандартной JRE
* исключать из стеков все участки кода от метода Thread.run до точки создания транзакционного логгера (что это такое - см ниже)
* исключать из логов все повторяющеся стеки для класса RuntimeException и его дочек
* при выдаче стека для исключений, имеющих непустой getCause() или getTargetException(), выдавать в трассу только первичный источник проблемы

Возможность исключения участков кода стандартной JRE сделано по очевидной причине - JRE, в большинстве своем, написана адекватными разработчиками, и текста сообщения об ошибке обычно вполне хватает для понимания ее причины. Повторяющиеся стеки для RuntimeException, если оно возникает всегда с одним и тем же стеком, ничего нового не дают к пониманию причин его возникновения - если при обработке 1000 записей из файла вы 1000 раз свалились по одной и той же причине, значит в вашем логе присутствует 999 //никому не нужных// стеков. Здесь я исхожу из тех же соображений, что и разработчики Java - RuntimeException должен сигнализировать об ошибках в //программном коде//, и эти ошибки надо не логировать, а //чинить//. Стек исключений, являющихся вторичными по отношению к другим исключениям, даже стандартными средствами Java сейчас выдается в редуцированном виде, просто в [[|LoggerFacade]] такой режим доведен до логического завершения.

Транзакционный режим логирования заключается в том, что для операции, во время которой существует вероятность неуспешного завершения, заранее создается временный //транзакционный// логгер. В него во время выполнения операции заносится максимально подробная информация о ходе операции. Если операция завершилась успешно, на этом логгере вызывается операция rollback(), и все его содержимое исчезает. Если же операция завершилась аварийно, мы сразу получаем максимально подробную трассу по ходу выполнения операции, и проблемы слишком-мало/слишком-много просто не возникает - ничего включать и повторно запускать не требуется. В плане программирования решение достаточно неудобное - логгер приходится прокидывать по всем вызовам, - но, как показала моя работа в нескольких проектах, никакой //другой// подход здесь просто не работает. К ошибкам надо готовиться заранее (в том числе и в плане логирования), а не спихивать проблему на потом.

Интерфейс [[|LoggerFacade]] в библиотеке PL реализуют три класса:

* класс [[|NullLoggerFacade]] - пустой логгер
* класс [[|PureLoggerFacade]] - переходник к стандартному JRE логгеру из пакета java.util.logging
* класс [[|SystemErrLoggerFacade]] - консольный логгер

== Механизм Java Scripting

Механизм подключаемых скриптоввых языков ([[https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/index.html|Java Scripting]]) позволяет подключать в программы на языке Java трансляторы других языков программирования. В библиотеке PL для поддержки этой воозможности имеется набор классов:

* классы [[|AbstractScriptEngine]] и [[|AbstractScriptEngineFactory]], представляющие собой заготовки реализаций соответствующиех классов и интерфейсов Java Scripting
* классы [[|AsmScriptEngine]] и [[|AsmScriptEngineFactory]], представляющие собой реализацию Java Scripting по отношению к классу [[|AsmWriter]]

В проекте funnyprolog с помощью этого механизма подтягивается в Java-приложение нтерпретатор языка Prolog.

== Динамические массивы примитивных типов

Если для ссылочных классов в Java имеются достаточно эффективные реализации динамических массивов, то динамические массивы примитивных типов в Java, по факту, отсутствуют (буферы примитивных типов из пакета java.nio таковыми не являются, поскольку их максимальный размер задается явным образом в момент создания, и выше заранее заданной границы вырасти не может). Отличительная особенность динамических массивов библиотки PL заключается в возможности выбора алгоритма расширения памяти под данные:

* расширение массива путем "удвоения"
* расширение путем добавления дополнительных участков элементов в список

Первый алгоритм (расширение путем удвоения) весьма популярен в классах JRE (навскидку можно назвать классы ByteArrayOutputStream и StringBuilder). Прекрасно работая на сравнительно небольших структурах данных, в высоконагруженных приложениях, обрабатывающих большие объемы данных, он является источником постоянной головной боли и частых MemoryOverflow, поскольку расходует памяти почти вдвое больше нужного и серьезно просаживает производительность пересылками при реорганизации данных. Имеенно по этой причине в массивах PL реализован и второй алгоритм - он заметно экономичнее по памяти, менее чувствителен к фрагментации, и не производит лишних пересылок. 

Динамические массивы PL определены для всех примитивных типов. Они имеют однотипный набор методов, но не являются ни наследниками друг друга, ни "дочками" какого-либо общего предка. Динамические массивы для типов **byte** и **char** имеют дополнительный набор методов и интерфейсов, позволяющий эффективно использовать их в операциях ввода-вывода.

== Динамические построители кода

Из классов, поддерживающих динамиеское построение кода, в первую очередь необходимо назвать [[|GettersAndSettersFactory]]. С определенными оговорками, можно назвать этот класс аналогом класса [[|MethodHandle]] JRE, более того - при построении кода, обеспечивающего доступ к непубличным полям классов, GettersAndSettersFactory использует по факту именно MethodHandle для реализации функциональности. Код доступа к публичным полям классов строится с помощью класса [[|AsmWriter]] и обеспечивает максимально эффективный доступ к полям. Класс GettersAndSettersFactory активно используется в библиотеке PL при сериализации данных, в работе класса [[|NanoServiceFactory]], а также в классах, обеспечивающих работу с экранными формами и ORM.

== Утилитные классы

Пакет purelib.basic содержит несколько классов, которые могут быть полезны в тех или иных ситуациях:

* классы [[|BitCharSet]] и [[|ExtendedBitCharSet]], предсталвяющие собой множества символов (аналог языка Pascal - set of char)
* класс [[|ClassLoaderWrapper]] - средство получить доступ к защищенному методу defineClass текущего загрузчика классов
* классы [[|FSM]] и [[|StackedFSM]] - средства реализации конечных автоматов Миля
* класс [[|LongIdMap]] - см ниже.
* класс [[|PluggableClassLoader]] - аналог класса URLClassLoader, но с возможностью динамического подключения и отключения дополнительных jar-файлов
* класс [[|ReusableInstances]] - см ниже.
* класс [[|SequenceIterator]] - класс, позволяющий объединять несколько итераторов в единый итератор (в качестве примерной аналогии см [[https://docs.oracle.com/javase/8/docs/api/java/io/SequenceInputStream.html|SequenceInputStream]])
* класс [[|TemporaryStore]] - см ниже
* класс [[|Utils]] - см ниже

=== Класс LongIdMap

Класс этот изначально использовался в классе [[|AndOrTree]], но может быть полезен и сам по себе. Он представляет собой дерево с ключами типа **long**, причем требуется, чтобы ключи занимали последовательные (или почти последовательные) номера. Время доступа к данным в LongIdMap не зависит от объема дерева, поскольку в нем используется прямая адресация данных. При соблюдении требования последовательности номеров объем занимаемой деревом памяти минимален.

=== Класс ReusableInstances

Класс позволяет многократно использовать ранее созданные экземпляры объектов, т.е. представляет, по сути дела, их кеш. Разработчики Java отмечали, что в новых версиях Java, с новыми механизмами выделения памяти и сборки мусора, необходимости в таком кеше нет. Жизнь, увы, показывает, что это далеко не всегда соответствует действительности.

=== Класс TemporaryStore

Класс TemporaryStore создан под вполне определенный сценарий использования, а именно:

* программист формирует временный набор данных (возможно, достаточно большого объема), и заносит его во временный файл
* программист считывает содержимое только что созданного временного файла и выполняет его обработку

Отличительная особенность класса TemporaryStore состоит в том, что он, по возможности, старается сохранять эти временные данные непосредственно в памяти приложения. Если их размер превысил определенную границу, они автоматически выгружаются во временный файл на диске. Во многих популярных проектах имеется реализация такой функциональности.

=== Класс Utils

Класс Utils полностью статический и содержит набор полезных методов, в числе которых:

* копирование содержимого байтовых и символьных потоков (в том числе с индикатором процесса копирования)
* формирование различных коллекций из пар ключ/значение
* загрузка байтовых и строковых данных из ресурсов приложения
* преобразование массивов примитивных типов в массивы классов-оберток и обратное преобразование, а также поиск класса-обертки для примитивного типа и обратный поиск
* методы валидации XML-данных по схемам, доступа к схемам XML библиотеки PL, а также метод обхода XML DOM-дерева
* методы преобразования URI
* метод рекурсивного удаления содержимого директории


