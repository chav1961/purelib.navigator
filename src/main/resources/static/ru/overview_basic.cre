= Пакет purelib.basic и его подпакеты. Общий обзор

Классы пакета [[/doc/chav1961.purelib/chav1961/purelib/basic/package-summary.html|purelib.basic]] и его подпакетов можно разделить на несколько групп:

* классы, предназначенные для поддержки консольных приложений
* классы, поддерживающие средства конфигурирования приложений
* классы, предназначенные для логирования работы приложений
* классы, поддерживающие механизм Java Scripting
* динамические массивы примитивных типов
* динамические построители кода
* утилитные классы

Рассмотрим подробнее каждую из упомянутых групп. 

== Поддержка консольных приложений

Для поддержки консольных приложений в библиотеке PL имеются два класса:

* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/ArgParser.html|ArgParser]], предназначенный для разбора аргументов командной строки
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/ConsoleCommandManager.html|ConsoleCommandManager]], преднаначенный для обработки и выполнения команд, вводимых с консоли

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/ArgParser.html|ArgParser]] автоматизирует процессы разбора аргументов командной строки приложения. Он поддерживает обработку позиционных и ключевых парамеров, различные типы аргументов (булевы, целочисленные, вещественные, строковые аргументы, различные виды URI, а также нумерации), опциональные и обязательные параметры. Для целочисленных параметров дополнительно можно указывать допустимый диапазон и/или список значений (например, для номера порта). С его помощью можно также выдать на консоль справку по использованию параметров запуска.

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/ConsoleCommandManager.html|ConsoleCommandManager]] принимает на вход строку, вводимую с консоли (поток **System.in**), выполняет ее синтаксический разбор и вызов на выполнение соответствующего обработчика команд. Обработчики команд - подключаемые. Задачи такого плана в практике программирования возникают нечасто, тем не менее сталкиваться с ними мне приходилось.

== Средства конфигурации приложений

Главный класс, активно используемый самой библиотекой PL для собственной конфигурации, называется [[/doc/chav1961.purelib/chav1961/purelib/basic/PureLibSettings.html|PureLibSettings]]. Через него в системе доступны локализатор [[/doc/chav1961.purelib/chav1961/purelib/i18n/PureLibLocalizer.html|PureLibLocalizer]], таймер для выполнения периодического обслуживания библиотеки PL, а также набор системных свойств приложения (переменные -D). В этих же свойствах можно задать (при запуске приложения) [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]] источника данных конфигурации (параметр **-Dpurelib.settings.source=<URI>**), из которого система загрузит параметры конфигурации вашего приложения. В качестве URI допустимо использовать любой правильный [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]], поддерживаемый приложением, в тоом числе и ссылки на компоненты [[./overview_fsys.cre|файловых систем]] и [[./overview_net.cre|схемы]], поддерживаемые PL. Доступ к параметрам конфигурации можно получить через метод **PureLibSettings.instance()**. Тип возвращаемого этим методом результата - [[/doc/chav1961.purelib/chav1961/purelib/basic/SubstitutableProperties.html|SubstitutableProperties]]. Класс этот - "дочка" класса [[https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html|Properties]], обеспечивающий две дополнительные возможности:

* механизм автоподстановки в параметрах источника данных конфигурации (например key1 = before **${key2}** after)
* механизм преобразования значений параметров в заданный тип (булево, целочисленное, вещественное, нумерация, URI, File, InputStream и ряд других)

== Средства логирования работы приложений

Логгеры нынче не пишет только ленивый. Однако, несмотря на, я бы сказал, //чрезмерное//, богатство выбора, все эти логгеры страдают двумя недостатками:

* логов, выдаваемых ими, бывает слишком мало, и по ним ничего нельзя понять
* логов, выдаваемых ими, бывает слишком много, и по ним тоже ничего нельзя понять

Одна из причин такого положения заключается в том, что заранее никогда не известно, когда и какая информация из логов может потребоваться для анализа ситуации. Типичный сценарий работы с логами имеет вид:

* получили неожиданное сообщение об ошибке, из которого ничего нельзя понять
* включили всю мыслимую трассу
* запустили приложение или задачу второй раз
* получили километры отладочной информации
* сели чесать репу

Т.е. чаще всего логи системы используются разработчиками как //еще одно// средство отладки приложений. Такой взгляд, вообще говоря, совершенно неверен. Достаточно сказать, что для многих клиентов эти логи представляют собой, по сути дела, протокол работы системы, и по этой причине подлежат //обязательному// хранению весьма длительное время. Визгу по поводу помойки, в которую обычно превращается такой лог, бывает предостаточно. В логгерах, безусловно, есть средства конфигурирования (в том числе и на лету), но их наличие, создавая иллюзию "все под контролем", никоим образом не избавляет от только что озвученного сценария. Вдоволь нахлебавшить этими изделиями на ряде проектов, я, в конце концов, разработал собственный вариант реализации логгеров. Упор в них сделан не на возможности конфигурирования, а совсем на другое. 

Основой всех логгеров в системе является интерфейс [[/doc/chav1961.purelib/chav1961/purelib/basic/interfaces/LoggerFacade.html|LoggerFacade]]. Отличительные его особенности следующие:

* режим редукции сообщений
* транзакционный режим логирования

Режим редукции сообщений позволяет автоматически выбрасывать из логов части трассы стеков, если в лог записывается сообщение об ошибке. Существуют несколько вариантов такого "выброса" в произвольных комбинациях:

* исключать из стеков все участки кода стандартной JRE
* исключать из стеков все участки кода от метода Thread.run до точки создания транзакционного логгера (что это такое - см ниже)
* исключать из логов все повторяющеся стеки для класса RuntimeException и его дочек
* при выдаче стека для исключений, имеющих непустой getCause() или getTargetException(), выдавать в трассу только первичный источник проблемы

Возможность исключения участков кода стандартной JRE сделано по очевидной причине - JRE, в большинстве своем, написана адекватными разработчиками, и текста сообщения об ошибке обычно вполне хватает для понимания ее причины. Повторяющиеся стеки для RuntimeException, если оно возникает всегда с одним и тем же стеком, ничего нового не дают к пониманию причин его возникновения - если при обработке 1000 записей из файла вы 1000 раз свалились по одной и той же причине, значит в вашем логе присутствует 999 //никому не нужных// стеков. Здесь я исхожу из тех же соображений, что и разработчики Java - RuntimeException должен сигнализировать об ошибках в //программном коде//, и эти ошибки надо не логировать, а //чинить//. Стек исключений, являющихся вторичными по отношению к другим исключениям, даже стандартными средствами Java сейчас выдается в редуцированном виде, просто в [[/doc/chav1961.purelib/chav1961/purelib/basic/interfaces/LoggerFacade.html|LoggerFacade]] такой режим доведен до логического завершения.

Транзакционный режим логирования заключается в том, что для операции, во время которой существует вероятность неуспешного завершения, заранее создается временный //транзакционный// логгер. В него во время выполнения операции заносится максимально подробная информация о ходе операции. Если операция завершилась успешно, на этом логгере вызывается операция rollback(), и все его содержимое исчезает. Если же операция завершилась аварийно, мы сразу получаем максимально подробную трассу по ходу выполнения операции, и проблемы слишком-мало/слишком-много просто не возникает - ничего включать и повторно запускать не требуется. В плане программирования решение достаточно неудобное - логгер приходится прокидывать по всем вызовам, - но, как показала моя работа в нескольких проектах, никакой //другой// подход здесь просто не работает. От слова **"совсем"**. К ошибкам надо готовиться заранее (в том числе и в плане логирования), а не спихивать проблему на потом.

Интерфейс [[/doc/chav1961.purelib/chav1961/purelib/basic/interfaces/LoggerFacade.html|LoggerFacade]] в библиотеке PL реализуют три класса:

* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/NullLoggerFacade.html|NullLoggerFacade]] - пустой логгер
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/PureLoggerFacade.html|PureLoggerFacade]] - переходник к стандартному JRE логгеру из пакета java.util.logging
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/SystemErrLoggerFacade.html|SystemErrLoggerFacade]] - консольный логгер

== Механизм Java Scripting

Механизм подключаемых скриптовых языков ([[https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/index.html|Java Scripting]]) позволяет подключать в программы на языке Java трансляторы других языков программирования. В библиотеке PL для поддержки этой воозможности имеются классы [[/doc/chav1961.purelib/chav1961/purelib/basic/AbstractScriptEngine.html|AbstractScriptEngine]] и [[/doc/chav1961.purelib/chav1961/purelib/basic/AbstractScriptEngineFactory.html|AbstractScriptEngineFactory]], представляющие собой заготовки реализаций соответствующиех классов и интерфейсов Java Scripting. В проекте [[https://github.com/chav1961/funnypro|Funny Prolog]] с помощью этого механизма подтягивается в Java-приложение интерпретатор языка Prolog.

== Динамические массивы примитивных типов

Если для ссылочных классов в Java имеются достаточно эффективные реализации динамических массивов, то динамические массивы примитивных типов в Java, по факту, отсутствуют (буферы примитивных типов из пакета java.nio таковыми не являются, поскольку их максимальный размер задается явным образом в момент создания, и выше заранее заданной границы вырасти не может). Отличительная особенность динамических массивов библиотеки PL заключается в возможности выбора алгоритма расширения памяти под данные:

* расширение массива путем "удвоения"
* расширение путем добавления дополнительных участков элементов в список

Первый алгоритм (расширение путем удвоения) весьма популярен в классах JRE (навскидку можно назвать классы [[https://docs.oracle.com/javase/8/docs/api/java/io/ByteArrayOutputStream.html|ByteArrayOutputStream]] и [[https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html|StringBuilder]]). Прекрасно работая на сравнительно небольших структурах данных, в высоконагруженных приложениях, обрабатывающих большие объемы данных, он является источником постоянной головной боли и частых MemoryOverflow, поскольку расходует памяти почти вдвое больше нужного и серьезно просаживает производительность пересылками при реорганизации данных. Имеенно по этой причине в массивах PL реализован и второй алгоритм - он заметно экономичнее по памяти, менее чувствителен к фрагментации, и не производит лишних пересылок. 

Динамические массивы PL определены в подпакете [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/package-summary.html|purelib.basic.growablearrays]] и включают в себя:
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableBooleanArray.html|GrowableBooleanArray]] для массивов **boolean**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableByteArray.html|GrowableByteArray]] для массивов **byte**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableCharArray.html|GrowableCharArray]] для массивов **char**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableDoubleArray.html|GrowableDoubleArray]] для массивов **double**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableFloatArray.html|GrowableFloatArray]] для массивов **float**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableIntArray.html|GrowableIntArray]] для массивов **int**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableLongArray.html|GrowableLongArray]] для массивов **long**
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableShortArray.html|GrowableShortArray]] для массивов **short**

Динамические массивы PL имеют однотипный набор методов, но не являются ни наследниками друг друга, ни "дочками" какого-либо общего предка. Динамические массивы [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableByteArray.html|GrowableByteArray]] и [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/GrowableCharArray.html|GrowableCharArray]] имеют в этом же пакете двух "дочек" ([[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/InOutGrowableByteArray.html|InOutGrowableByteArray]] и [[/doc/chav1961.purelib/chav1961/purelib/basic/growablearrays/InOutGrowableCharArray.html|InOutGrowableCharArray]] соответственно), реализующий ряд интерфейсов из пакета [[https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html|java.io]], позволяющих использовать их напрямую в операциях ввода-вывода.

== Динамические построители кода

Из классов, поддерживающих динамическое построение кода, в первую очередь необходимо назвать [[/doc/chav1961.purelib/chav1961/purelib/basic/GettersAndSettersFactory.html|GettersAndSettersFactory]]. С определенными оговорками, можно назвать этот класс аналогом класса [[https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html|MethodHandle]] JRE, более того - при построении кода, обеспечивающего доступ к непубличным полям классов, [[/doc/chav1961.purelib/chav1961/purelib/basic/GettersAndSettersFactory.html|GettersAndSettersFactory]] использует по факту именно [[https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html|MethodHandle]] для реализации функциональности. Код доступа к публичным полям классов строится с помощью класса [[/doc/chav1961.purelib/chav1961/purelib/streams/char2byte/AsmWriter.html|AsmWriter]] и обеспечивает максимально эффективный доступ к полям. Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/GettersAndSettersFactory.html|GettersAndSettersFactory]] активно используется в библиотеке PL при сериализации данных, в работе класса [[/doc/chav1961.purelib/chav1961/purelib/nanoservice/NanoServiceFactory.html|NanoServiceFactory]], а также в классах, обеспечивающих работу с экранными формами и ORM.

== Утилитные классы

Пакет purelib.basic содержит несколько классов, которые могут быть полезны в тех или иных ситуациях:

* классы [[/doc/chav1961.purelib/chav1961/purelib/basic/BitCharSet.html|BitCharSet]] и [[/doc/chav1961.purelib/chav1961/purelib/basic/ExtendedBitCharSet.html|ExtendedBitCharSet]], предсталвяющие собой множества символов (аналог языка Pascal - **set of char**)
* класс [[/doc/chav1961.purelib/chav1961/purelib/basic/ClassLoaderWrapper.html|ClassLoaderWrapper]] - средство получить доступ к защищенному методу **defineClass(...)** текущего загрузчика классов
* классы [[/doc/chav1961.purelib/chav1961/purelib/basic/FSM.html|FSM]] и [[/doc/chav1961.purelib/chav1961/purelib/basic/StackedFSM.html|StackedFSM]] - средства реализации конечных автоматов Миля
* класс [[#Класс LongIdMap|LongIdMap]] - см ниже.
* класс [[#Класс ReusableInstances|ReusableInstances]] - см ниже.
* класс [[|SequenceIterator]] - класс, позволяющий объединять несколько итераторов в единый итератор (в качестве примерной аналогии см [[https://docs.oracle.com/javase/8/docs/api/java/io/SequenceInputStream.html|SequenceInputStream]])
* класс [[#Класс TemporaryStore|TemporaryStore]] - см ниже
* класс [[#Класс Utils|Utils]] - см ниже
* класс [[#Класс CharUtils|CharUtils]] - см ниже
* класс [[#Класс URIUtils|URIUtils]] - см ниже
* класс [[#Класс XMLUtils|XMLUtils]] - см ниже

=== Класс LongIdMap

Класс этот изначально использовался в классе [[/doc/chav1961.purelib/chav1961/purelib/basic/AndOrTree.html|AndOrTree]], но может быть полезен и сам по себе. Он представляет собой дерево с ключами типа **long**, причем требуется, чтобы ключи занимали последовательные (или почти последовательные) номера. Время доступа к данным в LongIdMap не зависит от объема дерева, поскольку в нем используется прямая адресация данных. При соблюдении требования последовательности номеров объем занимаемой деревом памяти минимален.

=== Класс ReusableInstances

Класс реализует шаблон [[https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D0%BF%D1%83%D0%BB|"объектный пул"]] и позволяет многократно использовать ранее созданные экземпляры объектов, т.е. представляет, по сути дела, их кеш. Разработчики Java отмечали, что в новых версиях Java, с новыми механизмами выделения памяти и сборки мусора, необходимости в таком кеше нет. Жизнь, увы, показывает, что это далеко не всегда соответствует действительности.

=== Класс TemporaryStore

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/TemporaryStore.html|TemporaryStore]] создан под вполне определенный сценарий использования, а именно:

* программист формирует временный набор данных (возможно, достаточно большого объема), и заносит его во временный файл
* программист считывает содержимое только что созданного временного файла и выполняет его обработку

Отличительная особенность класса TemporaryStore состоит в том, что он, по возможности, старается сохранять эти временные данные непосредственно в памяти приложения. Если их размер превысил определенную границу, они автоматически выгружаются во временный файл на диске. Во многих популярных проектах имеется реализация такой функциональности.

=== Класс Utils

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/Utils.html|Utils]] полностью статический и содержит набор полезных методов, в числе которых:

* копирование содержимого байтовых и символьных потоков (в том числе с индикатором процесса копирования)
* формирование различных коллекций из пар ключ/значение
* загрузка байтовых и строковых данных из ресурсов приложения
* преобразование массивов примитивных типов в массивы классов-оберток и обратное преобразование, а также поиск класса-обертки для примитивного типа и обратный поиск
* метод рекурсивного удаления содержимого директории

=== Класс CharUtils

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/CharUtils.html|CharUtils]] полностью статический и содержит набор методов, позволяющих активно использовать их в различного рода синтаксических анализаторах, а также при формировании внешнего представления тех или иных данных:

* набор методов разбора чисел (целых, вещественных, со знаком, в различных системх счисления)
* набор методов разбора символьныъх строк, заключенных в кавычки или апострофы (в том числе содержащих внутри Escape-последовательности)
* набор методов разбора нумерованных констант и имен переменных (в том числе содержащих "нетрадиционные" символы)
* набор методов подстановки (по типу ${key} ), а также методов разделения и слияния строк
* набор дополнительных методов, которые могут потребоваься при анализе и формировании строк

Главная отличительная черта класса - все его методы работают почти исключительно с символьными массивами, а не с классом [[https://docs.oracle.com/javase/8/docs/api/java/lang/String.html|String]] . Благодаря этому при разработке парсеров устраняется промежуточный этап преобразования массива символов в строки, и обратно, что существенно улучшает производительность приложения.

Практически все методы разбора в данном классе имеют, как минимум, два входных параметра (собственно массив символов, и позицию, с которой требуется выполнить разбор), и возвращают в качестве результата номер позиции исходной строки после окончания разбора. Это возвращаемое значение может быть использовано затем в качестве начальной позиции исходной строки для последующих вызовов методов класса.

=== Класс URIUtils

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/URIUtils.html|URIUtils]] полностью статический и содержит набор методов, позволяющих облегчить работу с [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]]:

* набор методов загрузки данных с использованием [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]]
* набор методов манипуляции содержимым [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]] (извлечение подсхем, модификация путей, разбор строк запроса, глубокая нормализация и т.д.)

=== Класс XMLUtils

Класс [[/doc/chav1961.purelib/chav1961/purelib/basic/XMLUtils.html|XMLUtils]] полностью статический и содержит набор методов, позволяющих облегчить работу с XML DOM:

* набор методов загрузки с валидацией, с использованием XSD
* набор методов манипуляции содержимым XML DOM (обход дерева, манипуляции атрибутами вершины)
