= Пакет purelib.enumerations

Состав нумераций, входящих в этот пакет, сравнительно невелик, и включает в себя следующие нумерации:

* [[#%D0%BD%D1%83%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F+xsdcollection|XSDCollection]] - нумерация для доступа к XSD-схемам библиотеки PL;
* [[#%D0%BD%D1%83%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F+markupoutputformat|MarkupOutputFormat]] - нумерация для определения типа преобразования данных формата [[http://www.wikicreole.org|Creole]];
* [[#%D0%BD%D1%83%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F+nodeentermode+%D0%B8+continuemode|NodeEnterMode и ContinueMode]] - нумерации, используемые при обходе связнных структур данных

== Нумерация XSDCollection

В библиотеке PL имеется набор XSD-схем, предназначенных для контроля данных формата XML. Все они расположены в пакете [[|purelib.basic.xsd]]. Доступ к ним возможно получить с помощью метода [[upreliv.basic.Utils#create|purelib.basic.Utils.create()]]. Одним из параметров этого метода и является нумерация XSDCollection. Более подробно ее описание см [[|здесь]].

== Нумерация MarkupOutputFormat

Как было упомянуто в [[./overview.cre|обзоре]] библиотеки PL, формат [[http://www.wikicreole.org/|Creole]] является основным MarkUp Language библиотеки, и его поддержка встроена во все значимые классы. Указанная нумерация используется потоком [[|CreoleWriter]], с помощью которого возможно преобразовать формат Creole в другие форматы данных (например, HTML, XML или PDF). Более подробно ее описание см [[|здесь]].

== Нумерация NodeEnterMode и ContinueMode

{{/images/TreeWalking.png}} Эти нумерации активно используются во всех методах, выполняющих обход связной структуры данных (обычно это некая разновидность дерева). По такого рода структурам обычно выполняется либо обход от текущего узла к листьям, либо от текущего узла к корню. Первый вариант обхода в библиотеке PL обычно называется **walkDown**, а второй, соответственно, **walkUp**. Дополнительной особенностью связных структур, используемых в библиотеке PL (В частности, в средствах локализации), является то, что текущий узел может, помимо "дочек", иметь еще и "соседей" (у которых, естественно, могут тоже быть свои "дочки" и "родители").

Методы обхода связных структур библиотеки PL, в основном, написаны в одном ключе. В соответствии с реализованным в них алгоритмом, они выполняют движение по связной структуре. На каждом узле связной структуры, который попал в путь обхода, метод обхода выполняет обратный вызов (callback) заранее заданного метода обработки (в большинстве случаев - лямбда-выражения). Как правило, аргументами этого метода обработки являются:

* текущий узел связной структуры, для которого вызывается метод обработки
* режим обработки текущего узла:
** метод обхода "вошел" в текущий узел
** метод обхода закончил рекурсивный обход других узлов, связанных с данным, и "выходит" из текущего узла

Для варианта обхода **walkDown** в библиотеке PL принят следующий порядок обработки:

* программа "входит" в текущий узел
* программа, не выходя и текущего узла, рекурсивно "входит" во все "дочки" текущего узла, а затем "выходит" из них
* программа "выходит" из текущего узла

Для варианта обхода **walkUp** в библиотеке PL принят следующий порядок обработки:

* программа "входит" в текущий узел
* программа, не выходя и текущего узла, рекурсивно "входит" во всех "соседей" текущего узла, а затем "выходит" из них (подъем из "соседей" в их "родителей" при этом не происходит)
* программа, не выходя из текущего узла, рекурсивно "входит" в "родителя" текущего узла, а затем "выходит" из него
* программа "выходит" из текущего узла

Для обозначеия факта "входа" и выхода" из того или иного узла используется нумерация [[|NodeEnterMode]]. Ее значения:

* **ENTER** - выполняется "вход" в текущий узел
* **EXIT** - выполняется "выход" из текущего узла

Метод обработки, при своей работе, может вмешаться в порядок обхода связной структуры. Для этого метод обработки, как правило, //возвращает// в метод обхода то или иное значение. Тип этого значения представлен нумерацией [[|ContinueMode]] и может быть:

* **CONTINUE** - продолжить обход обычным путем
* **SIBLINGS_ONLY** - пройти по "соседям", но не подниматься в "родителя" (имеет смысл только для **walkUp**)
* **PARENT_ONLY** - не пытаться заходить в "соседей", пройдя только по "родительской" ветке (имеет смысл только для **walkUp**)
* **SKIP_SIBLINGS** - пропустить обход "соседей" текущего узла и продолжить обработку его "родителей" (имеет смысл только для **walkUp**). В отличие от PARENT_ONLY, не запрещает заходить в "соседей" "родительских" узлов
* **SKIP_CHILDREN** - пропустить обработку "дочек" текущего узла и продолжить обход (имеет смысл только для **walkDown**)
* **SKIP_PARENT** - пропустить обработку "родителя" текущего узла (имеет смысл только для **walkUp**)
* **STOP** - немедленно прекратить обход

Независимо от указанного значения, программы обхода гарантируют, что для всех узлов, в которые был выполнен "вход", будет также выполнен и "выход" (сказанное не распространяется на случай возникновения исключения при обработке)

Метод обработки не обязательно должен возвратить одинаковые значение для вызова при "входе" и при "выходе". Для различных значений методы обхода выбирают "наихудший" вариант. Если, например, метод **walkDown** при "входе" в узел вернул STOP, а при "выходе" - CONTINUE, метод обхода прекратит дальнейший обход связной структуры. Если же при "входе" в узел метод обработки вернул CONTINUE, а при "выходе" - STOP, метод обхода также прекратит дальнейший обход, но в "дочках" он, тем не менее, побывает.



