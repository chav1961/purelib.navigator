= Пакет purelib.json. Работа с фильтрами

Фильтр JSON, имеющийся в пакете [[/doc/chav1961.purelib/chav1961/purelib/json/package-summary.html|purelib.json]], по своим возможностям подобен механизму XPath XML. Приведем пример его использования:

{{{	JsonUtils.walkDownJson(root,JsonUtils.filterOf("/[]#$ = 300 && $ is int",(mode,node,path)->{
		// TODO: process node found and it's children
		return ContinueMode.CONTINUE;	
	));}}}

Если на вход метода walkDownJson будет подано дерево, соответствующее JSON "[100,200,300,300.0]", фильтр позволит обработать в нем только третий элемент массива (он равен 300 и целочисленный). Другой пример:

{{{	JsonUtils.walkDownJson(root,JsonUtils.filterOf("/*1#$ is arr",(mode,node,path)->{
		// TODO: process node found and it's children
		return ContinueMode.CONTINUE;	
	));}}}

Если на вход метода [[/doc/chav1961.purelib/chav1961/purelib/json/JsonUtils.html|JsonUtils.walkDownJson(...)]] будет подано дерево, соответствующее JSON "{"var1":10,"var11":[1,2,{"f1":10}]}", фильтр позволит обработать в нем только поле "var11" и его элементы 1, 2, и {"f1":10}, поскольку имя этого поля заканчивается на единицу, а содержимое представляет собой массив.

== Синтаксис описания фильтра

Фильтр описывается следущим шаблоном:

<стартовый_узел><селектор_узла>

Стартовый узел представляет собой символ "/", означающий корень дерева. В фильтрах, используемых //внутри// выражений, в качестве стартового узла допустимо также использовать конструкции "./" (ссылка на текущую вершину дерева JSON) и "../" (ссылка на родительскую вершину дерева JSON), а также их произвольные комбинации. Селектор узла имеет следующий формат:

<путь_в_дереве>[**:**<фильтр_значений>][**#**<фильтр_условий>][<селектор_узла>]

=== Путь в дереве

Путь в дереве может быть задан одним из указанных способов:

* **/** - любой узел "вниз" от предыдущего
* **/[]** - любой узел "вниз" от предыдущего, при условии, что предыдущий узел является массивом
* **/<шаблон_имени>** - любой узел "вниз" от предыдущего, при условии, что предыдущий узел является объектом с именованными полями
* **/[<индексное_выражение>]** - любой узел "вниз" от предыдущего, при условии, что предыдущий узел является массивом и индекс текущего узла удовлетворяет заданному условию
* **/~** ** - любая цепочка узлов в дереве JSON

В качестве шаблона имени допустимо использовать буквы, цифры, знаки подчеркивания, а также два специальных символа шаблона:

* *** ** - любая последовательность разрешенных символов (в том числе пустая)
* **?** - ровно один разрешенный символ

Индексное выражение позволяет указать, какие именно элементы массива подлежат обходу. В качестве выражения может быть использован либо список диапазонов индексов, либо конструкция **has**, за которой следует логическое выражение. В выражении допустимо использовать:

* целочисленные константы
* переменную **i**, означающую в данном контексте индекс текущего элемента массив
* знаки арифметических операций **+**, **-**, **~***, **/**, **%** с общепринятым приоритетом, а также унарный минус
* знаки операций сравнения ** > ** , ** >= **, ** < **, ** <= ** , ** = ** (или ** == **), **<>**, а также операцию <выражение> **in** <список_диапазонов>, аналогичную оператору IN языка SQL
* знаки логических операций **~~ ** (НЕ), **&&** (И), **~|~|** (ИЛИ) с общепринятым приоритетом
* круглые скобки

Примеры:

* **/** - корень дерева и все его поддеревья. Равносильно отсутствию фильтра
* **~//** - все поддеревья дерева, за исключением самого корня
* **/~**/[]** - все массивы, встречающиеся в дереве (в том числе и корень, если он является массивом)
* **/~**/*1** - все поля структур дерева, имена которых заканчиваются на единицу, а также поддерево значений, хранящееся в таких полях
* **/[0,2..4]** - элементы 0, 2, 3, 4 из корня-массива
* **/[has i % 2 = 0]** - четные элементы из корня-массива

=== Фильтр значений

Фильтр значений представляет собой список интервалов, в который должно попадать значение, хранящееся в текущей вершине дерева.

Пример:

* **/[]:10,20..100** - все элементы корня-массива, значение которых равно 10 или лежит в диапазоне от 20 до 100 включительно

=== Фильтр условий

Фильтр условий представляет собой логическое выражение. В нем допустимо употреблять:

* символьные, целые, вещественные, булевы константы (**true** и **false**), а также константу **null**
* переменную **$**, означающую в данном контексте содержимое текущей вершины дерева
* знаки арифметических операций **+**, **-**, **~***, **/**, **%** с общепринятым приоритетом, а также унарный минус
* знаки операций сравнения **>** , **>= **, **<**, **<= ** , **= ** (или **== **), **<>**, а также операцию <выражение> **in** <список_диапазонов>, аналогичную оператору IN языка SQL
* операцию <выражение> **is** {**int**~|**real**~|**bool**~|**str**~|**obj**~|**arr**~|**null**} для проверки типа данных указанного выражения. Типы выражений соответствуют типам узлов дерева JSON, определенным в нумерации [[/doc/chav1961.purelib/chav1961/purelib/json/interfaces/JsonNodeType.html|JsonNodeType]]
* знаки логических операций **~~** (НЕ), **&&** (И), **~|~|** (ИЛИ) с общепринятым приоритетом
* круглые скобки
* фильтры (с обязательным стартовым узлом)
* специальную конструкцию вида **'<синтаксически_правильный_JSON>'**, описывающую дерево JSON, которую можно употреблять в правой части операторов ** = ** и ** <> **

Указание фильтра в выражении трактуется как "проверить наличие данной конструкции" и вызвращает в качестве результата значения **true** или **false**. Указание фильтра в качестве операнда операторов сравнения предписывает проверить содержимое соответствующих заданному фильтру данных.

Примеры:

* **/~**#../name** - все поля всех именованных объектов, если в данном объекте присутствует поле **name**
* **/~**#../name = '{"key":"n1","value":10}'** - все поля всех именованных объектов, если в данном объекте присутствует поле **name**, и его содержимое в точности представляется в виде **{"key":"n1","value":10}**
* **/~**/*1#$ = ../*2** - все поля всех именованных объектов, имя которых заканчивается единицей, при условии, что в этом же объекте присутствует поле с именем, заканчивающимся на двойку, и содержимое этих двух полей совпадает

Если в селекторе узла присутствуют дополнительные селекторы узла, для избежания неоднозначностей рекомендуется заключать фильтр условий в круглые скобки, например:

* **/~**#(../name)/[has i % 2 = 0]** - все четные элементы всех полей-массивов всех именованных объектов, если в данном объекте присутствует поле **name**

