= Библиотека Pure Library. Общий обзор
Библиотека [[https://github.com/chav1961/purelib|Pure Library]] (далее **PL**) //не// задумывалась как очередная //серебряная пуля// для решения всех мыслимых и немыслимых задач, встречающихся в программистской практике. По сути дела, она представляет собой всего лишь сравнительно небольшой набор полезных классов, которые можно применять при написании различных приложений на языке Java. Некоторые из них были целенаправленно разработаны, некоторые образовались спонтанно при работе над различными проектами. Если кому-то они в том или ином виде пригодятся - буду только рад. 

При разработке PL мной был принят ряд решений, правильность которых я не намерен обсуждать. Ниже они кратко перечислены:

* библиотека PL не должна использовать //никакого стороннего// программного обеспечения, кроме того, что явно присутствует в комплекте Java JDK (даже если вся она будет представлять собой гигантский велосипед)
* в качестве упрощенного языка разметки (MarkUp Language) в библиотеке PL будет повсеместно использоваться язык разметки Creole (см http://www.wikicreole.org/ ), а не MarkDown, как это принято в подавляющем большинстве проектов. Поддержка этого языка должна быть встроена как в саму библиотеку PL, так и в средства ее документирования
* библиотека PL изначально должна содержать единые встроенные средства интернационализации, независимо от того, будут ли ее использовать в мультиязыковых приложениях, или нет
* при разработке библиотеки PL первостепенное внимание будет уделяться производительности составляющих ее классов (при необходимости - даже в ущерб ее функциональности)

В репозитарии проектов, помимо собственно библиотеки PL, присутствует также достаточно большое количество проектов на ее основе. Сразу оговорюсь, что практически все они разрабатывались не только с утилитарной целью, но как //подопытные кролики// для проверки библиотеки PL (достаточность функциональности, удобство и легкость использования, полезность того или иного класса и т.д.). Если тот или иной проект будет вызывать своим существованием //недоумение//, следует вспомнить именно об этой его роли.

= Состав библиотеки Pure Library
Как и принято в языке Java, библиотека содержит в себе ряд пакетов, в которых сгруппированы соответствующие классы. Текущая версия содержит следующий набор пакетов:

* пакет [[./overview_cdb.cre|purelib.cdb]], в котором сгруппированы классы, используемые при написании компиляторов и интерактивных отладчиков Java-программ;
* пакет [[./overview_concurrent.cre|purelib.concurrent]] и его подпакеты, в которых сгруппированы классы, используемые при параллельном программировании;
* пакет [[./overview_enumerations.cre|purelib.enumerations]], в котором сгруппирован ряд нумераций, широко используемых в библиотеке PL;
* пакет [[./overview_fsys.cre|purelib.fsys]] и его подпакеты, в которых сгруппированы классы, поддерживающие модель //файловых систем// библиотеки PL;
* пакет [[./overview_i18n.cre|purelib.i18n]] и его подпакеты, в которых сгруппированы классы, поддерживающие механизм интернационализации библиотеки PL;
* пакет [[./overview_internal.cre|purelib.internal]], в котором сгруппированы классы, используемые при документировании библиотеки PL;
* пакет [[./overview_json.cre|purelib.json]], в котором сгруппированы классы, обеспечивающие работы с данными формата JSON;
* пакет [[./overview_model.cre|purelib.model]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу с //моделями данных// библиотеки PL;
* пакет [[./overview_nanoservice.cre|purelib.nanoservice]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу //встроенного http-сервера// библиотеки PL;
* пакет [[./overview_sql.cre|purelib.sql]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу с протоколом JDBC;
* пакет [[./overview_streams.cre|purelib.streams]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу со специальными потоками данных (среди них необходимо особо отметить потоки обработки формата [[http://www.wikicreole.org/|Creole]], а также [[|поток-ассемблер]] байт-кода Java со встроенным макропроцессором);
* пакет [[./overview_ui.cre|purelib.ui]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу с GUI;
* пакет [[./overview_ui_swing.cre|purelib.ui.swing]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу с Java Swing GUI;
* пакет [[./overview_ui_web.cre|purelib.ui.web]] и его подпакеты, в которых сгруппированы классы, обеспечивающие работу с Web HTML GUI
* пакет [[./overview_basic.cre|purelib.basic]] и его подпакеты, в которых сгруппированы классы, не попавшие в другие пакеты;

Помимо перечисленных пакетов, библиотека PL содержит набор JUnit-тестов к ним, а также дополнительные файлы, необходимые для работы библиотеки.

= Использование библиотеки Pure Library

Общий обзор библиотеки PL был бы неполон, если бы мы не остановились подробно на отдельных аспектах ее использования. Ниже будут рассмотрены вопросы применения библиотеки PL при:

* разработке [[#Pure Library и компиляторы|компиляторов]] и отладчиков Java-кода
* поддержке формата [[#Pure Library и язык разметки Creole|Creole]]
* работе с [[#Pure Library и работа с внешними данными|внешними данными]]
* [[#Pure Library и интернационализация|интернационализации]] приложений
* работе с форматом [[#Pure Library и JSON|JSON]]
* работе с форматом [[#Pure Library и HTML|HTML]]
* взаимодействии с [[#Pure Library и базы данных|базами данных]]
* написании [[#Pure Library и графические приложения|графических приложений]]

Помимо этого, будет дан краткий обзор классов, которые могут быть полезны сами по себе, безотносительно той или иной области программирования

== Pure Library и компиляторы

Мне достаточно часто приходилось иметь дело с разработкой компиляторов, поэтому библиотека PL содержит немалое число классов, предназначенных для поддержки процесса компиляции. К ним, в первую очередь, следует отнести:

* классы, реализующие интерфейс [[|SyntaxTreeInterface]] - различного рода таблицы имен, широко используемые в процессе компиляции
* класс [[|SyntaxTreeNode]] - элементы синтаксического дерева
* классы [[|CharUtils]] и [[|LineByLineProcessor]] - парсеры исходных текстов, подлежащих компиляции
* класс [[|AsmWriter]] - компилятор байт-кода Java в формат файла *.class со встроенным макроассемблером
* класс [[|CompilerUtils]] - утилитный класс, предназначенный для совместного использования с классом AsmWriter

Поскольку все процессы синтаксического разбора, как правило, выполняются путем посимвольной обработки входных данных, практически все упомянутые классы работают не со строковыми данными, а с //массивами символов//. Это - сознательное решение, необходимое для получения масимальной производительности и минимизации расхода памяти при компиляции (в том числе за счет исключения ненужных пересылок и преобразований данных). 

Классов, реализующих интерфейс [[|SyntaxTreeInterface]], в библиотеке PL два:
* [[|AndOrTree]] - разновидность [[https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE|префиксного дерева]], которая разрабатывалась для получения максимальной производительности при работе с деревьями имен
* [[|OrdinalSyntaxTree]] - дерево, реализованное на основе стандартного Java-класса [[|TreeMap]]

Классы являются полностью взаимозаменяемыми (по крайней мере, по результатам работы JUnit-тестов). Различие между ними - в форме хранения ключей: класс AndOrTree хранит ключи в виде символьных массивов, а класс - OrdinalSyntaxTree - в виде строк.
В тех случаях, когда работа с деревом преполагается большей частью со строковыми данными, выгоднее будет использовать OrdinalSyntaxTree, при работе большей частью с символьными массивами - AndOrTree. Подробное описание их функциональности см [[|здесь]].

Класс [[|SyntaxTreeNode]], реализующий узел синтаксического дерева, содержит минимальный набор полей, достаточных для реализации синтаксического дерева в компиляторе. Помимо самого класса, в пакете [[|]] имеется также утилитный класс, поддерживающий, в частности, обход синтаксического дерева. Подробное описание функциональности этих классов см [[|здесь]].

Класс [[/redir/zzz|CharUtils]] содержит парсеры большинства типов данных, которые встречаются на входе компиляторов - целые и вещественные числа, строки, имена, нумерации. Он также может выполнять и обратные преобразования соответствующих типов данных в последовательности символов. Помимо этого, с его помощью можно выполнять ряд дополнительных действий (сравнение символьных массивов, быстрое разделение и слияние символьных массивов, подстановку значений переменных в строку и т.д.). Подробное описание его функциональности см [[|здесь]].

Класс [[|LineByLineProcessor]] эффективно поддерживает часто используемую на практике задачу - разделить входной поток данных на строки и выполнить их построчную обработку. В отличие от стандартных Java классов, при его работе практически не образуется мусора, а пересылки данных сведены к минимуму. Подробное описание его функциональности см [[|здесь]].

Класс [[|AsmWriter]] представляет собой полноценный компилятор байт-кода Java в файл формата *.class. //Идейным вдохновителем// этого класса явился проект [[http://jasmin.sourceforge.net/|Jasmin]]. С точки зрения программиста, класс представляет собой обычный символьный поток вывода (наподобие System.out), в который программист может выводить строка-за-строкой текст программы на Java-ассемблере. На выходе потока при этом //волшебным образом// образуется файл *.class. Для автоматизации процесса компиляции поток снабжен встроенным [[https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80#%D0%9C%D0%B0%D0%BA%D1%80%D0%BE%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80|макроассемблером]]. В отличие от проекта [[https://asm.ow2.io/|Asm]] и аналогичных ему, для пользования этим классом достаточно знания [[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html|команд байт-кода]] Java, и чтения [[|краткого руководства]] по макроассемберу, хотя он, безусловно, не позволяет //изменять// код существующих классов (собственно, он для этого и //не предназначался//). Класс [[|CompilerUtils]] позволяет упростить процесс написания команд Java-ассемблера. Возможности класса AsmWriter широко используются внутри самой библиотеки PL для построения байт-кода на лету в тех местах, где необходимо получить максимальную производительность. Подробное описание этих классов см [[|здесь]].

== Pure Library и язык разметки Creole

Язык Creole был выбран в качестве основного языка разметки библиотеки PL по двум важным для меня лично причинам:

* описание [[http://www.wikicreole.org|Creole]] содержит вменяемый //контрольный пример//, в отличие от описания MarkDown (или его вольных трактовок)
* грамматика языка Creole является регулярной, и допускает эффективный разбор, в отличие от грамматики MarkDown

Для работы с языком Creole в библиотеке имеется класс [[|CreoleWriter]], устроенный по тому же принципу, что и класс [[|AsmWriter]]: символьный поток вывода, в который выводятся данные в формате Creole, а на выходе которого получаются данные, преобразованные в соответствующий формат (HTML, XML, PDF и т.д.). Автоматическое преобразование формата Creole в формат HTML встроено в http-сервер библиотеки PL, а также в классы, поддерживающие интернационализацию.

== Pure Library и работа с внешними данными

В основе работы с внешними данными лежит понятие //файловой системы//. В Java версии 1.7 уже было введено аналогичное понятие, и оно во многом перекликается с понятием файловой системы библиотеки PL. Отличительной особенностью файловых систем библиотеки PL является:

* возможность работы с //подключаемыми// типами файловых систем
* поддержка операций //монтирования// и размонтирования файловых систем
* поддержка операций //слияния// файловых систем

Файловые системы подключаются в приложение с помощью стандартного механизма [[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html|SPI]], инкапсулированного в классе [[/doc/chav1961.purelib/chav1961/purelib/fsys/FileSystemFactory.html|FileSystemFactory]]. Как показали события с выпуском Java 1.9, это - единственный механизм, о котором разработчики Java позаботились и намерены заботиться и впредь. В самой библиотеке PL имеется набор файловых систем, для работы которых не требуется стороннее ПО (это, как было отмечено в начале, принципиальное решение). Состав их следующий:

* файловая система для "обычного" доступа к директориям и файлам компьютера
* файловая система-переходник к файловым системам Java, поддерживаемым стандартным JRE
* файловая система для данных, хранящихся непосредственно в памяти приложения
* файловая система для данных, представленных в виде XML

В проекте [[https://github.com/chav1961/purelib.ext|Pure Library Extension]] имеется набор файловых систем для доступа к репозитариям Git, SVN, Amazon S3 и т.д. Описание операций монтирования и слияния файловых систем см [[./overview_fsys.cre#Монтирование и слияние|здесь]]

Все файловые системы библиотеки PL реализуют интерфейс [[/doc/chav1961.purelib/chav1961/purelib/fsys/interfaces/FileSystemInterface.html|FileSystemInterface]], независимо от природы файловой системы. Практически все классы библиотеки PL, работа которых так или иначе связана с доступом ко внешним данным, используют именно этот интерфейс при своей работе.

== Pure Library и интернационализация

Встроенная поддержка интернационализации библиотеки PL основана на понятии [[|локализатора]]. Локализатором является любой класс, реализущий интерфейс [[|Localizer]]. Локализаторы в программе образуют //дерево// локализаторов. В свою очередь, группа локализаторов может образовывать список локализаторов. Локализаторы подключаются в приложение с помощью стандартного механизма [[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html|SPI]], инкапсулированного в классе [[|LocalizerFactory]].

Интерфейс [[|Localizer]] поддерживает следующие операции с деревом локализаторов:

* подсоединение локализатора как "дочки" (образование //поддерева// локализаторов)
* подсоединение локализатора как "соседа" (образование //списка// локализаторов)
* отсоединение локализатора

Процесс работы локализатора библиотеки PL практически не отличается от большинства известных способов реализации - поиск по //ключу// соответствующего //значения// для заданного //языка//. Поиск значения ведется в текущем локализаторе, затем в его соседях, а затем рекурсивно продолжается в родительском поддереве (вплоть до корня). Благодаря операциям подсоединения локализаторов, в программе не требуется вести общий список локализуемых ключей и значений, а возможно строить его на лету при использовании тех или иных классов. Корнем дерева локализаторов в библиотеке PL является класс [[|PureLibLocalizer]], содержащий определения ключей и значений для всех локализуемых классов библиотеки PL.

Классы приложения, использующие средства локализации, могут //подписаться// на событие изменения языка приложения. Для этого используется интерфейс [[|LocaleChangeListener]]. В качестве значений, связанных с ключами, во всех локализаторах допустимо употребление языка разметки [[http://www.wikicreole.org/|Creole]].

== Pure Library и JSON

Библиотека PL содержит ряд классов, обеспечивающих поддержку формата JSON в соответствии со стандартом [[https://tools.ietf.org/html/rfc7159|RFC 7159]]. В их число входит:

* класс [[|JsonSaxParser]], являющийся JSON-аналогом популярного [[https://ru.wikipedia.org/wiki/SAX|SAX]]-парсера формата XML
* классы [[|JsonStaxParser]] и [[|JsonStaxPrinter]], являющийся JSON-аналогами популярных [[https://en.wikipedia.org/wiki/StAX|StAX]]-парсера и райтера формата XML
* класс [[|JsonSerializer]], подерживающий процесс сериализации и десериализации объектов Java-программы в формат JSON

Отличительная особенность всех указанных классов - высокая скорость обработки данных в формате JSON. Достигнуто это как за счет использования эффективных алгоритмов разбора, так и полным исключением рефлексии при реализации указанных классов. Последний момент важен не только потому, что рефлексия существенно замедляет работу любого Java-приложения, но и тем, что, с выходом Java 1.9, разработчики Java если уж не объявили рефлексии //войну//, то существенно урезали ее в правах. Исключение рефлексии достигнуто как за счет применения новой функциональности Java (в частности, класса [[https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html|MethodHandle]]), так и построением байт-кода на лету для наиболее критичных участков программы (класс [[|AsmWriter]] и все, что с ним связано). Все классы обеспечивают обработку формата JSON только //в потоке//,  JSON-аналогов [[https://ru.wikipedia.org/wiki/Document_Object_Model|DOM]] в библиотеке PL нет и не планируется. Подробное описание класса JsonSaxParser см [[|здесь]], классов JsonStaxParser и JsonStaxPrinter - [[|здесь]], и класса JsonSerializer - [[|здесь]].

== Pure Library и HTML

Библиотека PL содержит в своем составе встроенный HTTP-сервер (на базе [[https://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html|com.sun.net.httpserver.HttpServer]]). Класс, его реализующий, называется [[|NanoServiceFactory]]. Назначение его двоякое:

* поддержка режима онлайн-справки (Help) для приложений на Java
* поддержка простого WEB-сервера, который может быть встроен в приложение на Java

Онлайн-справка позволяет использовать обычный WEB-браузер для получения справки о возможностямх Вашей программы, существенно упростив тем самым разработку справочной системы (а заодно получив все плюшки и шишки формата HTML). Встроенный HTTP-сервер содержит не только средства для поддержки статического контента, но и механизм подключаемых обработчиков (plugin), подобный [[https://ru.wikipedia.org/wiki/REST|RESTFul-сервисам]] (это, в частности, позволяет разрабатывать на его основе приложения, поддерживающие трехзвенную архитектуру). Средства поддержки WEB UI, о которых будет сказано ниже, используют для своей работы именно этот класс. 

При разработке класса [[|NanoServiceFactory]] основной упор был также сделан на максимальную производительность приложения, поэтому в нем активно используется построение байт-кода на лету. Класс обеспечивает поддержку не только формата HTML, но и формата XML и JSON.

== Pure Library и базы данных

Практика работы над крупными проектами подвела меня к мысли о программно формируемых тестовых наборах данных, доступ к которым обеспечивается с помощью интерфейсов [[https://ru.wikipedia.org/wiki/Java_Database_Connectivity|JDBC]]. Поднять постоянно доступный сервер БД для использования в JUnit-тестах далеко не всегда возможно (о //правильности// такого подхода умолчу, дабы не разводить холивары), поэтому в библиотеке PL имеется большой набор классов, позволяющий формировать тестовые выборки (интерфейс [[|ResultSet]]) из различных не-базовых источников данных (например, файлов формата CSV). Источники данных подключаются в программу с помощью стандартного механизма [[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html|SPI]], инкапсулированного в классе [[|ResultSetFactory]]. Непосредственно в библиотеке PL реализовано три источника тестовых данных:

* файлы формата CSV ([[https://www.ietf.org/rfc/rfc4180.txt|RFC 4180]])
* файлы формата JSON ([[https://tools.ietf.org/html/rfc7159|RFC 7159]])
* файлы формата XML

Доступ ко всем источникам данных реализуется через механизм файловых систем (см работу с [[#Pure Library и работа с внешними данными|внешними данными]]). Дополнительные источники данных, требующие применения стороннего ПО, имеются в проекте [[https://github.com/chav1961/purelib.ext|Pure Library Extension]]. Помимо целей тестирования, эти источники данных можно применять и самостоятельно, для обработки данных соответствующего формата средствами JDBC.

== Pure Library и графические приложения

Практика работы с многочисленными клиентами, а также участие в некоторых крупных проектах, подвели меня к одной крамольной мысли: полностью исключить разработку графических интерфейсов из процесса написания Java-приложений. Идея состоит в том, что разработка любого графического интерфейса
практически невозможна без участия человека, а трудозатраты на разработку графики нередко превышают все остальные трудозатраты по проекту вместе взятые. Все современные IDE решают эту проблему путем предоставления разработчику все более и более совершенных инструментов для создания GUI, мне же захотелось поступить в точности наоборот - отобрать у разработчиков GUI последнее. Многочисленные примеры клиентов, ведущих едва ли не всю свою бухгалтерию в MS Excel, //титанические// возможности которого в области GUI общеизвестны, дают основание полагать, что задача эта не является невыполнимой. Кроме того, по моим личным наблюдениям, в крупных корпоративных системах не менее 80% всех экранных форм либо используются время от времени, либо вообще один-единственный раз (например, при установке). Тратить время и силы на их разработку и сопровождение не вижу никаких причин.

Для реализации этой идеи в библиотеке PL имеется пакет [[|model]], с помощью которого можно строить //модели// представления той или иной сущности в программе на Java. Построенная тем или иным способом модель передается затем интерпретатору модели 
(в настоящий момент в бибилотеке реализованы интерпретаторы для Swing и WEB), который уж как-нибудь должен преобразовать ее в более-менее приемлемую форму на экране. Указанный подход не нов - в том же [[https://ru.wikipedia.org/wiki/JavaFX|JavaFX]] имеется описатель FXML. Принципиальное отличие 
модели в библиотеке PL заключается в том, что в ней нет //абсолютно никаких данных//,  касающихся представления того или иного ее элемента на экране. Так, узнав из модели, что поле класса представляет собой нумерацию, интерпретатор должен самостоятельно построить для нее
выпадающий список, заполнить его допустимыми значениями, приткнуть его в более-менее логичное место на экране и обеспечить связь между текущим значением поля класса, и тем, что показывается на экране. Построенная таким образом форма, конечно, будет хуже hand-made, но у такого подхода есть, как минимум, два плюса:

* поскольку модель не содержит никакой специфики относительно представления данных, то по ней можно построить и //любой// вариант представления данных (Swing, WEB, зеленый терминал - далее по списку)
* интерфейс многих систем (не будем тыкать пальчиком в [[http://1c.ru/|1C]]) не отличается особой изысканностью, что не мешает этим системам быть суперпопулярными на рынке. Существуют сотни приложений, где нужны не "шашечки", а "ехать"

Основной источник моделей в бибилиотеке PL - класс [[|ContentModelFactory]]. Интерпретатор моделей - класс [[|UIServer]]. Встроенные в бибиотеку интерпретаторы моделей подключаются к нему по интерфейсу [[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html|SPI]]. В библиотеке PL в настоящий момент их два:

* интерпретатор Java Swing
* интепретатор WEB-интерфейса (использует для работы класс [[|NanoServiceFactory]])

Помимо этих классов, в библиотеке PL имеется и достаточно большой набор полезных классов, которые можно напрямую использовать в Swing-приложениях, в частности:

* строка состояния для Swing-приложений (сообщения, Progress Bar, история)
* манипулятор контента для Swing-приложений (создание, открытие, сохранение, закрытие, список последних)
* поле ввода/редатирования даты
* поле ввода/выбора имени файла
* поле редактора с подсветкой синтаксиса (в частности, Creole)
* визуальные классы для работы с файловыми системами
* эмулятор терминала
* и т.д.

== Дополнительные классы Pure Library 

Большинство дополнительных классов бибилиотеки PL можно разделить на несколько групп:

* классы, предназначенные для поддержки консольных приложений (класс [[|ArgParser]] для обработки параметров командной строки, и класс [[|ConsoleCommandManager]], реализующий обработку команд, вводимых с консоли)
* классы, предназначенные для логирования работы приложений (классы, реализующие интерфейс [[|LoggerFacade]])
* классы, поддерживающие механизм Java Scripting
* классы, реализующие ряд полезных функций:
** динамические массивы примитивных типов
** классы, реализующие конечные автоматы
** утилитные классы различного назначения
* классы, поддерживающие средства конфигурирования приложений (класс [[|SubstitutableProperties]] и [[|PureLibSettings]])