= Работа с файловыми системами (пакет purelib.fsys)

Понятие файловой системы, как уже было [[./overview.cre#Pure Library и работа с внешними данными|упомянуто]], появилось в языке Java, начиная с версии 1.7. Основное отличие файловых систем библиотеки PL - возможность расширения их состава с помощью подключаемых по [[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html|SPI]] модулей, а также наличие двух специальных операций, не имеющих аналога в файловых системах JRE:

* монтирование файловых систем
* слияние файловых систем

Все файловые системы идентифицируются исключительно с помощью соответствующих им [[https://docs.oracle.com/javase/8/docs/api/java/net/URI.html|URI]], и в этом качестве могут быть использованы в любом месте, где допустимо использование URI. Схема всех URI для файловых систем называется **fsys**, специфичный для данной схемы контент, в свою очередь, также содержат соответствующую типу той или иной файловой системы схему, и дополнительный идентификатор ресурса, описывающий расположение конкретной файловой системы. В библиотеке PL имеются классы, реализующие следующие типы файловых систем:

|= тип ФС |= форма записи URI |= комментарий |
|ФС в ОЗУ | fsys:memory/ | общий пул памяти приложения, в котором можно создавать папки и файлы, доступные всем \\ потокам приложения. Назависимо от числа экземпляров файловой системы, работает с одними\\и теми же областями памяти (по сути дела, является singleton-классом)|
|ФС на файловой системе компьютера | fsys:file:/<корень_ФС> | поддерево на одном из дисков компьютера, в котором можно читать и модифицировать файлы и папки.\\Работает только с содержимым поддерева, корень которого задан в URI, подняться выше этого корня невозможно. |
|ФС на файловой системе Java | fsys:fsys:/<корень_ФС>| файловая система библиотеки PL над файловой системой Java |
|ФС на XML-файле | fsys:xmlReadOnly:<URI_файла>| файловая система на содержимом XML файла (XSD-схема XMLReadOnlyFSys.xsd). Обычно используется\\ для монтирования других файловых систем |
|ФС на ресурсах приложения | fsys:root:<локатор_класса>| файловая система на ресурсах приложения. Позволяет получить доступ к ресурсам приложения,\\ аналогично методам getClass().getResource()|
|ФС на механизме RMI | fsys:rmi:<адрес_RMI_сервера>!\\ <URI_файловой_системы> | файловая система, обеспечивающая удаленный доступ к любой файловой системе удаленного RMI-сервера|

Другие типы файловых систем размещены в проекте [[https://github.com/chav1961/purelib.ext|Pure Library Extension]]

Базовая функциональность файловых систем описывается в PL интерфейсом [[/doc/chav1961.purelib/chav1961/purelib/fsys/interfaces/FileSystemInterface.html|FileSystemInterface]] из пакета [[/doc/chav1961.purelib/chav1961/purelib/fsys/interfaces/package-summary.html|purelib.fsys.interfaces]]. Для упрощения написания собственных реализаций файловых систем в пакете [[/doc/chav1961.purelib/chav1961/purelib/fsys/package-summary.html|purelib.fsys]] имеется абстрактный класс [[/doc/chav1961.purelib/chav1961/purelib/fsys/AbstractFileSystem.html|AbstractFileSystem]], с использованием которого написаны все реализации файловых систем библиотеки PL. Настоятельно рекомендую использовать этот класс как базовый для написания ваших собственных файловых систем. Помимо собственно файловых систем, в пакете [[/doc/chav1961.purelib/chav1961/purelib/fsys/package-summary.html|purelib.fsys]] присутствует также загрузчик классов [[/doc/chav1961.purelib/chav1961/purelib/fsys/FileSystemClassLoader.html|FileSystemClassLoader]]. С его помощью возможна загрузка файлов ** *.class**, а также любых ресурсов приложения, с любой из поддерживаемых библиотекой PL (и ее расширениями) файловых систем. Одним из вариантов применения загрузчика, в частности, является запуск приложения из репозитариев кода (типа Git, SVN и т.д.), что, в некотором роде, аналогично (но не тождественно) механизму [[https://ru.wikipedia.org/wiki/Java_Web_Start|JavaWS]] языка Java.
==Работа с файловыми системами

Работа с файловыми системами PL достаточно стандартизована, и основана на нескольких типовых шаблонах. Получить реализацию интерфейса [[/doc/chav1961.purelib/chav1961/purelib/fsys/interfaces/FileSystemInterface.html|FileSystemInterface]] для того или иного типа файловой системы можно с помощью класса [[/doc/chav1961.purelib/chav1961/purelib/fsys/FileSystemFactory.html|FileSystemFactory]]:

{{{try(final FileSystemInterface fsi = FileSystemFactory.createFileSystem(URI.create("fsys:file:./"))) {
	/* TODO:... */
} }}}

В данном примере мы получаем доступ к файловой системе на жестком диске, корнем которой является рабочая директория вашего приложения. Файловая система реализует интерфейс [[https://docs.oracle.com/javase/8/docs/api/java/io/Closeable.html|Closeable]], и обязательно должна быть закрыта после использования, поэтому рекомендую всегда использовать ее в блоках **try-with-resources**.

Файловая система PL на является совместно используемой, поскольку, по факту, имеет внутри себя //курсор//, указывающий на место в содержимом файловой системы, с которым в данный момент ведется работа. Чтобы упростить совместную работу с файловой системой одновременно нескольким потокам (или одному потоку одновременно в нескольких месах файловой системы), рекомендую использовать следующию идиому:

{{{try(final FileSystemInterface myFsi = fsi.clone()) {
	/* TODO:... */
} }}}

Склонированная файловая система является полной копией исходной файловой системы, но ее курсор может находиться в любом другом месте содержимого. 

Все методы интерфейса [[/doc/chav1961.purelib/chav1961/purelib/fsys/interfaces/FileSystemInterface.html|FileSystemInterface]] возвращают в качестве результата либо запрошенное данным методом значение, либо ссылку на самого себя, что позволяет использовать этот интерфейс в цепочках вызовов, например:

{{{try(final FileSystemInterface myFsi = fsi.clone().open("/mydir").deleteAll().mkDir()) {
	/* TODO:... */
} }}}
В данном примере мы устанавливаем курсор файловой системы на директорию "/myDir", удаляем ее вместе с содержимым и тут же пересоздаем заново - уже пустую.

Клоны файловой системы **не являются** равноценной файловой системой, а представляют собой, по сути дела, "дочек" исходной файловой системы. При закрытии той инстанции файловой системы, от которой был создан клон, все ее клоны также будут автоматически закрыты. В силу такой особенности реализации операция клонирования по производительности получается практически "бесплатной". Это еще одна из причин пользоваться методом clone() для организации одновременной работы с одной и той же файловой системой.
==Монтирование и слияние

//Монтирование// файловых систем в точности соответствует командам Linux **mount** и **umount**, и позволяет собирать единую файловую систему из разнородных кусков. Программисту эта возможность дает ровно те же преимущества, что и соответствующие команды Linux. Файловая система на базе [[/doc/chav1961.purelib/chav1961/purelib/fsys/FileSystemOnXMLReadOnly.html|XML]] (URI **fsys:xmlReadOnly:<URI_файла>**) позволяет описать эту операцию непосредственно внутри соответствующего файла** *.xml**, получив, таким образом, //гетерогенную// файловую систему (такая функциональность в файловых системах JRE отсутствует). Можно таким способом, например, собрать общую файловую систему локального компьютера и [[https://aws.amazon.com/ru/s3/|Amazon s3]], и работать с ней, как с единым целым.

//Слияние// файловых систем в некотором роде похоже на механизм переопределения в объектном программировании. При слиянии двух файловых систем одна из них **"заслоняет"** своими файлами и директориями другую. При попытке доступа к тому или иному файлу (директории) его имя ищется вначале в **"заслоняющей"** файловой системе, а затем - в **"заслоняемой"**. При создании новых сущностей они всегда создаются в **"заслоняющей"** файловой системе. При модификации существующих файлов и директорий они изменяются в том месте, где были реально найдены. Слиянием файловых систем удобно пользоваться в тех случаях, когда, например, **"заслоняемая"** файловая систем доступна программмисту только на чтение - в этом случае с помощью "заслоняющей" файловой системы можно произвести //временную подмену// файлов и папок. Сливать можно и более чем две файловых системы одновременно - при этом в месте слияния образуется **стек** файловых систем.